var http = require('http');
var url  = require('url');
var fs   = require('fs'); 
var sys  = require('sys');

var responseHandler;
var interceptors = [];
var cfg = {};

module.exports.createServer = function(target_host, target_port) {

	cfg = {
		host: target_host,
		secure: false,
		target_port: target_port
	};
	
	var server = http.createServer(frontEndListener);
	
	return {
		setInterceptors: function(rules) {
			interceptors = rules;
		},
		listen: function(port) {
			server.listen(port);
		},
		setResponseListener: function(handler) {
			responseHandler = handler;
		}
	};
}

var init = function() {
	cfg = {
		host: 'yourhost',
		secure: false,      // true for https connections
		target_port: 80,    // 443 for https connections
		listen_port: 8001,  // tip listens on this port
		interceptor_file: './interceptors.js'  // contains descriptions calls which should be intercepted and how
	}
	response_header = {'Connection':'keep-alive',
	  		'Content-Type':	'application/json',
			'Referer':'http://localhost:8001/flo/src/portal/',
			'Server': 'Translucent Intercepting Proxy 0.1 / La Gentz KG'};  // response_header for intercepted responses

	var parm,key;
	process.argv.forEach(function (val, index, array) {
		parm = val.split("=");
  		if(parm.length==2){
  			for(key in cfg){
  				if(parm[0]==key){
  					cfg[key]=parm[1];
  				}
  			}
  		}
	});
			
			
	fs.watchFile(cfg.interceptor_file, update_interceptors);  // add a watch to interceptor_filename to automagically refresh interceptors
	sys.log("Starting Translucent Intercepting Proxy");
	sys.log("   Forwarding Requests to: "+cfg.host);
	sys.log("   Listening at Port: "+cfg.listen_port);
	interceptors =[];
	update_interceptors();  // initial load of interceptors
	createFrontEndListener();
};

var update_interceptors = function(c,p) {
	sys.log('   Updating request / response pairs');
	var file_buf = fs.readFileSync(cfg.interceptor_file);
	try{
		eval(file_buf.toString('utf8'));
	}
	catch(ex){
		// keep 'em silent
	}
	sys.log("   Read following interceptors: "+JSON.stringify(interceptors));
};

// hit returns true, if o1's keys and values can be found in o2
var hit = function(o1, o2) {
	var i;
	for (i in o1) {
		if (typeof o1[i] == typeof o2[i]) {
			if (typeof o1[i] == 'object') {
				if (!hit(o1[i], o2[i])) {
					return false;
				}
			} else if (typeof o1[i] != 'function' && o1[i] != o2[i]) {
				return false;
			}
		} else {
			return false;
		}
	}
	return true;
};

var createFrontEndListener = function() {
	http.createServer(frontEndListener).listen(cfg.listen_port);
};

var parseJSON = function(res) {
		var jres;
	  	try{
	  		jres = JSON.parse(res);
	  	}
	  	catch(ex){
	  		return null;
	  	}
	  	return jres;
};

var frontEndListener = function(frontEndRequest, frontEndResponse) {
 	var backEndClient = http.createClient(cfg.target_port, cfg.host, cfg.secure);
 	frontEndRequest.headers["accept-encoding"] = "";
	var backEndRequest = backEndClient.request(frontEndRequest.method, frontEndRequest.url, frontEndRequest.headers);
	
	var interceptHandler = null;
	backEndRequest.addListener('response', function (backEndResponse) {
		var binary = true;
		response_header = backEndResponse.headers;
		if(backEndResponse.headers["content-type"] !== undefined) {
			binary = (backEndResponse.headers["content-type"].indexOf("application/json") < 0);
		}
		var backEndResponseBuffer=[];
		backEndResponse.addListener('data', function(chunk) {
			if(binary) {
				frontEndResponse.write(chunk, "binary");  // plain passthrough of data
			} else {	
				backEndResponseBuffer.push(chunk.toString("utf-8")); // collecting the chunks (json)
			}
		});
		
		backEndResponse.addListener('end', function() {
			if(binary) {
				frontEndResponse.end();  // end of passthrough (non-json)	
			} else {
				var interception;
				if(typeof responseHandler === 'function') {
					interception = responseHandler(frontEndRequest.url.split('?')[0], parseJSON(backEndResponseBuffer.join("")));
				}
				if(interception) {  // json interception
					var args = {  // prepare request from the FrontEnd and Request from the Backend for the interceptHandler
						//request: JSON.parse(frontEndRequestBuffer.join("")),
						response: JSON.parse(backEndResponseBuffer.join(""))
					};
					//var new_response = interceptHandler(args, frontEndRequest);
					frontEndResponse.writeHead(200,response_header);  // writing our own header
					frontEndResponse.write(JSON.stringify(interception), "binary");
				} else {
					frontEndResponse.writeHead(backEndResponse.statusCode, backEndResponse.headers);  // putting the backendResponse to the FrontEnd
					frontEndResponse.write(backEndResponseBuffer.join(""), "utf-8");  // no interceptHandler, just write the backendResponse 
					//feedResponse(frontEndRequest.url.split('?')[0], backEndResponseBuffer.join(""));
				}
				backEndResponseBuffer = [];  // clear buffer.
				frontEndResponse.end();	
			}
		});
		if(binary){
			frontEndResponse.writeHead(backEndResponse.statusCode, backEndResponse.headers);
		}
	});
  	
	var frontEndRequestBuffer = [];
  	frontEndRequest.addListener('data', function(chunk) {
		frontEndRequestBuffer.push(chunk); // adding up the response
	});
	
  	frontEndRequest.addListener('end', function() {
	  	var res = frontEndRequestBuffer.join("");
		var jres = parseJSON(res);
	  	var intercepted = false;
	  	//if(!!jres)
	  	//{
	  		var j;
	  		// lookup incoming requests in interceptors
	  		for(j=0;j<interceptors.length;j++){
	  			//if(frontEndRequest.url.match(interceptors[j].method) !== null){  // first check for method
				if(frontEndRequest.url == interceptors[j].method){
					//if(hit(interceptors[j].request,jres)){  // then check request-description
						if(typeof interceptors[j].response === 'function'){  // if it's a function, submit the call to the BackEnd
																			 // and remember the interceptHandler
							backEndRequest.write(res, 'binary');  
	    					backEndRequest.end();
							interceptHandler = interceptors[j].response;
						}
						else
						{
							// Assume a plain JSON intercepted response
							frontEndResponse.writeHead(200,response_header);
							frontEndResponse.write(JSON.stringify(interceptors[j].response)); 
							frontEndResponse.end();
						}
						intercepted = true;
						break;	// stop after first match!
					//}
	  			}
			}
	  	//}
	  	// if nothing's intercepted, the request is passed without any modification
	  	if(!intercepted) {
	  		backEndRequest.write(res, 'binary');
	    	backEndRequest.end();
	  	}
  	});
};

//init();
